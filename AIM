-- AimAssistMobile.lua
-- Coloque este LocalScript em StarterPlayerScripts
-- Atualizado: sempre ativo, UI removida, alcance aumentado e verificação de linha de visão melhorada
-- Observação: use apenas em seu próprio jogo / para aprendizado. Usar para trapacear em jogos alheios
-- pode violar os Termos do Roblox.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera

-- Configurações (ajustadas)
local MAX_DISTANCE = 8000    -- distância máxima para considerar um inimigo (studs) - aumentada bastante
local MAX_FOV_DEG = 45       -- ângulo máximo (graus) do centro da tela para considerar alvo
local SMOOTHNESS = 8         -- quanto maior, mais rápido o ajuste da câmera (lerp)
local CHECK_RATE = 0.033     -- intervalo entre checagens (s)
local HEAD_OFFSET = Vector3.new(0, 1.5, 0) -- onde mirar no personagem inimigo (aprox. cabeça)

-- Estado
local assistActive = true -- sempre ativo
local lastTick = 0

-- Retorna o personagem e o ponto alvo (Vector3) se válido
local function getCharacterAimPoint(player)
    if not player.Character then return nil end

    local head = player.Character:FindFirstChild("Head")
    -- tenta encontrar o "peito"/torso em R15/R6/legacy:
    local upperTorso = player.Character:FindFirstChild("UpperTorso") or player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("HumanoidRootPart")

    -- Se tivermos cabeça e torso, mire no ponto médio entre os dois (meio termo: cabeça <-> peito)
    if head and upperTorso then
        return (head.Position + upperTorso.Position) / 2
    end

    -- Fallbacks: se apenas cabeça
    if head then
        return head.Position + HEAD_OFFSET
    end

    -- se apenas torso/HRP
    if upperTorso then
        -- aproximar-se do peito um pouco acima do centro do torso
        return upperTorso.Position + Vector3.new(0, 1.0, 0)
    end

    return nil
end

-- Verifica linha de visão simples (raycast) entre a câmera e o ponto do alvo.
-- Agora recebe também targetCharacter para determinar se o primeiro hit é o próprio alvo.
local function hasLineOfSight(point, targetCharacter)
    if not camera then return false end
    local origin = camera.CFrame.Position
    local direction = (point - origin)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local ignore = {}
    if localPlayer and localPlayer.Character then
        table.insert(ignore, localPlayer.Character)
    end
    params.FilterDescendantsInstances = ignore

    local result = workspace:Raycast(origin, direction, params)
    -- Se não houve nenhum hit, consideramos que há LOS
    if not result then
        return true
    end

    if result and result.Instance then
        -- Se o primeiro hit fizer parte do próprio alvo, então LOS existe
        if targetCharacter and result.Instance:IsDescendantOf(targetCharacter) then
            return true
        end
        -- Caso contrário está obstruído
        return false
    end

    return false
end

-- Retorna o jogador inimigo mais próximo (por distância) satisfazendo filtros
local function findClosestEnemy()
    local bestPlayer = nil
    local bestDist = MAX_DISTANCE + 1
    if not camera then return nil end
    local camPos = camera.CFrame.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= localPlayer and p.Character and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            -- checa times (se aplicável)
            local isEnemy = true
            if localPlayer.Team and p.Team and (localPlayer.Team == p.Team) then
                isEnemy = false
            end
            if isEnemy then
                local aimPoint = getCharacterAimPoint(p)
                if aimPoint then
                    local dist = (aimPoint - camPos).Magnitude
                    if dist <= MAX_DISTANCE and dist < bestDist then
                        -- checa ângulo de FOV (quanto está próximo do centro da câmera)
                        local lookVector = camera.CFrame.LookVector
                        local dir = (aimPoint - camPos).Unit
                        local dot = math.clamp(lookVector:Dot(dir), -1, 1)
                        local angle = math.deg(math.acos(dot))
                        if angle <= MAX_FOV_DEG then
                            -- checa linha de visão (agora verifica se o primeiro hit é o alvo)
                            if hasLineOfSight(aimPoint, p.Character) then
                                bestPlayer = p
                                bestDist = dist
                            end
                        end
                    end
                end
            end
        end
    end
    return bestPlayer
end

-- Aponta a câmera suavemente para targetPos
local function aimAt(targetPos, dt)
    if not camera then return end
    local camPos = camera.CFrame.Position
    local desiredCFrame = CFrame.new(camPos, targetPos)
    local alpha = 1 - math.exp(-SMOOTHNESS * dt)
    camera.CFrame = camera.CFrame:Lerp(desiredCFrame, alpha)
end

-- Gatilho principal: loop de atualização
local heartbeatConn
local function startLoop()
    if heartbeatConn then return end
    heartbeatConn = RunService.Heartbeat:Connect(function(dt)
        lastTick = lastTick + dt
        if lastTick < CHECK_RATE then return end
        lastTick = 0

        if not assistActive then return end
        if not camera or not camera.Parent then return end
        if not localPlayer.Character then return end

        local enemy = findClosestEnemy()
        if enemy then
            local aimPoint = getCharacterAimPoint(enemy)
            if aimPoint then
                aimAt(aimPoint, CHECK_RATE)
            end
        end
    end)
end

-- Inicialização: sem UI (sempre ativo)
startLoop()

-- Observers para atualização de filtro quando personagem for trocado (opcional)
Players.PlayerRemoving:Connect(function(p)
    -- nada a fazer; garbage collection normal
end)

-- Nota: este script manipula a câmera do cliente local. Para que os tiros realmente acertem o inimigo
-- no servidor, o sistema de armas do seu jogo deve usar a direção atual da câmera do cliente ou aplicar
-- correção no servidor (ex: projectiles que procuram o alvo). Este script apenas move a mira do jogador.
